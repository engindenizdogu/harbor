<style>
  /* Hide sublists until JS applies persisted state to avoid flicker */
  .sidebar-nav:not(.ready) .sidebar-sublist { visibility: hidden; }
  /* Optional: give smoother paint when animating */
  .sidebar-sublist { will-change: height; }
</style>

<nav class="sidebar-nav" aria-label="Notes">
  {%- comment -%}
    Hierarchical sidebar
    --------------------
    We build a nested folder → notes listing from the `site.notes` collection.
    Only notes under `_notes/Public/` are shown. Subfolders inside `Public/` become
    collapsible sections. Root-level notes (directly under `Public/`) are listed first.

    Liquid limitations: We simulate a set of unique folder names using an array we push into.
    Paths may contain either forward or backslashes depending on OS, so we check both.
    "Relative path" here means the portion after `_notes/Public/`.
  {%- endcomment -%}

  {%- assign public_notes = site.notes | where_exp: "n", "n.path contains '/Public/' or n.path contains '\\Public\\'" -%}
  {%- assign public_notes = public_notes | sort: 'title' -%}

  {%- comment -%} Build unique folder list {%- endcomment -%}
  {%- assign folders = '' | split: '' -%}
  {%- for n in public_notes -%}
    {%- assign rel = n.path | replace: '_notes/Public/', '' | replace: '_notes\\Public\\', '' -%}
    {%- if rel contains '/' or rel contains '\\' -%}
      {%- if rel contains '/' -%}
        {%- assign folder = rel | split: '/' | first -%}
      {%- else -%}
        {%- assign folder = rel | split: '\\' | first -%}
      {%- endif -%}
      {%- unless folders contains folder -%}
        {%- assign folders = folders | push: folder -%}
      {%- endunless -%}
    {%- endif -%}
  {%- endfor -%}
  {%- assign folders = folders | sort -%}

  <ul class="sidebar-list">
    {%- comment -%} Folder sections {%- endcomment -%}
    {%- for folder in folders -%}
      <li class="sidebar-folder">
        <details class="sidebar-details" data-folder-name="{{ folder }}">
          <summary class="sidebar-folder-name">{{ folder }}</summary>
          <ul class="sidebar-sublist">
            {%- for note in public_notes -%}
              {%- assign rel = note.path | replace: '_notes/Public/', '' | replace: '_notes\\Public\\', '' -%}
              {%- if rel contains '/' or rel contains '\\' -%}
                {%- if rel contains '/' -%}
                  {%- assign segments = rel | split: '/' -%}
                {%- else -%}
                  {%- assign segments = rel | split: '\\' -%}
                {%- endif -%}
                {%- if segments[0] == folder -%}
                  <li class="sidebar-item sidebar-subitem{%- if page.url == note.url -%} active{%- endif -%}">
                    <a class="sidebar-link" href="{{ site.baseurl }}{{ note.url }}">{{ note.title }}</a>
                  </li>
                {%- endif -%}
              {%- endif -%}
            {%- endfor -%}
          </ul>
        </details>
      </li>
    {%- endfor -%}

    {%- comment -%} Root-level notes (no subfolder) after folders {%- endcomment -%}
    {%- for note in public_notes -%}
      {%- assign rel = note.path | replace: '_notes/Public/', '' | replace: '_notes\\Public\\', '' -%}
      {%- unless rel contains '/' or rel contains '\\' -%}
        <li class="sidebar-item{%- if page.url == note.url -%} active{%- endif -%}">
          <a class="sidebar-link" href="{{ site.baseurl }}{{ note.url }}">{{ note.title }}</a>
        </li>
      {%- endunless -%}
    {%- endfor -%}
  </ul>
  
  <button class="sidebar-collapse-all" onclick="collapseAllFolders()">Collapse All ↑</button>
</nav>

<script>
  (function () {
    // Persist sidebar folder open/closed state across page navigations
    // Runs only once on initial page load (not on client-side navigation)
    if (window.sidebarInitialized) return;
    window.sidebarInitialized = true;

    var STORAGE_KEY = 'sidebarOpenFolders';
    function readOpenSet() {
      try {
        var raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return new Set(); // Start with all folders collapsed
        var arr = JSON.parse(raw);
        return new Set(Array.isArray(arr) ? arr : []);
      } catch (e) {
        return new Set();
      }
    }
    function writeOpenSet(set) {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(Array.from(set)));
      } catch (e) {
        // ignore write errors (e.g., private mode)
      }
    }

    window.collapseAllFolders = function() {
      var detailsList = document.querySelectorAll('.sidebar-details[data-folder-name]');
      detailsList.forEach(function(det) {
        if (det.open) {
          det.removeAttribute('open');
        }
      });
      // Clear storage
      writeOpenSet(new Set());
    };

    function init() {
      var nav = document.querySelector('.sidebar-nav');
      var detailsList = document.querySelectorAll('.sidebar-details[data-folder-name]');
      if (!detailsList.length) {
        if (nav) nav.classList.add('ready');
        return;
      }

      var openSet = readOpenSet();
      var isInitialLoad = true;

      function animateOpen(sub) {
        if (!sub) return;
        // Start from 0, then expand to scrollHeight
        sub.style.overflow = 'hidden';
        sub.style.height = '0px';
        sub.style.transition = 'height 200ms ease';
        requestAnimationFrame(function () {
          sub.style.height = sub.scrollHeight + 'px';
        });
        sub.addEventListener('transitionend', function onEnd() {
          sub.removeEventListener('transitionend', onEnd);
          sub.style.transition = '';
          sub.style.overflow = '';
          sub.style.height = '';
        });
      }

      function animateClose(sub) {
        if (!sub) return;
        // Collapse from current height to 0
        sub.style.overflow = 'hidden';
        sub.style.height = sub.scrollHeight + 'px';
        sub.style.transition = 'height 200ms ease';
        requestAnimationFrame(function () {
          sub.style.height = '0px';
        });
        sub.addEventListener('transitionend', function onEnd() {
          sub.removeEventListener('transitionend', onEnd);
          sub.style.transition = '';
          sub.style.overflow = '';
          sub.style.height = '';
        });
      }

      detailsList.forEach(function (det) {
        var name = det.getAttribute('data-folder-name');
        if (!name) return;
        var sub = det.querySelector('.sidebar-sublist');

        // Add toggle listener (skips animation on initial load)
        det.addEventListener('toggle', function () {
          if (isInitialLoad) return; // No animation on page load
          if (det.open) {
            openSet.add(name);
            writeOpenSet(openSet);
            animateOpen(sub);
          } else {
            openSet.delete(name);
            writeOpenSet(openSet);
            animateClose(sub);
          }
        });

        // Apply persisted state (triggers toggle but animation skipped)
        if (openSet.has(name) && !det.open) {
          det.setAttribute('open', '');
        }
      });

      // Mark initial load done, reveal sidebar
      isInitialLoad = false;
      if (nav) nav.classList.add('ready');
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }
  })();
</script>
